# 第 7 章 - 快速排序
[My Github Link](https://github.com/kehuo/algorithm_py3)

## 本章引言

对于包含 n 个数的输入数组来说, 快速排序是一种最坏情况时间复杂度为 O(n^^2) 的排序算法。虽然最坏
情况时间复杂度很差，但是快速排序通常是实际排序应用中最好的选择，因为它的平均性能非常好。它的期
望时间负责是 O(nlgn), 而且 O(nlgn) 中隐含的常数因子非常小。另外，它还能够进行原址排序，甚至
在虚存环境中也能很好的工作。

7.1 节将描述快速排序算法以及它的一个重要的划分子程序。因为快速排序的运行情况比较复杂，在 7.2 节
中我们会先对其性能进行一个直观的讨论，在本章最后会给出一个准确的分析。在 7.3 节中，我们会介绍一
个基于随机抽样的快速排序算法，这一算法的期望时间复杂度较好，而且没有什么特殊的输入会导致最坏情况
的发生。 7.4 节对这一随机算法的分析表明，其最坏情况时间复杂度是 O(n^^2)； 在元素互异的情况下，
期望时间复杂度是 O(nlgn)。


# 7.1 快速排序的描述 

与归并排序一样，快速排序也使用了 2.3.1 节介绍的分治思想。下面是对一个典型的子数组 A\[p, ..., r]
进行快速排序的 3 个分治过程:
> ***分解***: 数组 A\[p, ..., r] 被划分为 2 个 (可能为空) 的子数组 A\[p, ..., q-1] 和
> A\[q+1, ..., r]，这个分组使得 A\[p, ..., q-1] 中的每一个元素都小于等于 A\[q]， 而 A\[q] 也
> 小于等于 A\[q+1, ..., r] 中的每一个元素。其中，计算下标 q 也是划分过程的一个部分。

> ***解决***: 通过递归调用快速排序, 对子数组 A\[p, ..., q-1] 和 A\[q+1, ..., r] 进行排序。

> ***合并***: 因为子数组都是原址排序的，所以不需要合并操作，也就是说数组 A\[p, ..., r] 已经有序。


## 伪代码实现
    QUICKSORT(A, p, r)
    1 if p < r
    2     q = PARTITION(A, p, r)
    3     QUICKSORT(A, p, q-1)
    4     QUICKSORT(A, q+1, r)
 
为了排序一个数组 A 的全部元素, 初始调用时 QUICKSORT(A, 1, A.length)。

其中 ***数组的划分*** 是算法的关键部分，即下面的 PARTITION 伪代码。这个 PARTITION 过程实现了
对子数组 A\[p, ..., r] 的原址重排。

    PARTITION(A, p, r)
    1 x = A[r]
    2 i = p - 1
    3 for j = p to r-1
    4     if A[j] <= x
    5         i = i + 1
    6         exchange A[i] with A[j]
    7 exchange A[i+1] with A[r]
    8 return i + 1

## python3 实现以及算法解释

building...
