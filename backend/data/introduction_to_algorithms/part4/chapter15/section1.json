{
  "part": {
    "num": "4",
    "title": "高级设计和分析技术"
  },
  "chapter": {
    "num": "15",
    "title": "动态规划"
  },
  "main": {
    "num": "1",
    "title": "钢条切割",
    "content": {
      "overview": "钢铁切割问题是动态规划相关的一个经典问题.\n它可以有3种实现方式, 第一种用递归实现, 第二种和第三种用2种动态规划的方法实现.\n1. rec函数 - 自顶向下的递归方法\n(很差的方法, 指数级的时间复杂度, 列出来只是为了引出动态规划)\n2. 动态规划的2种等价实现:\n    2.1 memoized 函数 - 带备忘的 \"自顶向下\" 法 - (top-down with memoization)\n    2.2 bottom_top 函数 - 自底向上法 (bottom-up method)",
      "pseudo_code": [
        "自顶向下 - 递归 - CUT-ROD\n    该程序每当 n 增加 1, 运行时间可能就要增加 1 倍. 时间复杂度非常高.\n    对于 n = 40, 可能要运行 1 个小时才能得到结果\n\n    p: 价格数组\n    n: 钢条初始长度\n\n    CUT-ROD(p, n)\n    1 if n == 0\n    2     return 0\n    3 q = -1\n    4 for i = to n\n    5     q = max(q, p[i] + CUT-ROD(p, n-i))\n    6 return q",
        "带备忘的自顶向下动态规划实现 - memoized\n    这里的 memoized 并没有拼写错误, 他是 memo 这个单词的延伸, memo的意思是 \"备忘\"\n\n    MEMOIZED-CUT-ROD(p, n)\n    1 let r[0, 1, ..., n] be a new array\n    2 for i = 0 to n\n    3   r[i] = -1\n    4 return MEMOIZED-CUT-ROD-AUX(p, n, r)\n\n    其中 MEMOIZED-CUT-ROD-AUX 函数定义如下\n    MEMOIZED-CUT-ROD-AUX(p, n, r)\n    1 if r[n] >= 0\n    2     return r[n]\n    3 if n == 0\n    4     q = 0\n    5 else q = -1\n    6 for i = 1 to n\n    7     q = max(q, p[i] + MEMOIZED-CUT-ROD-AUX(p, n-i, r))\n    8 r[n] = q\n    9 return q",
        "自底向上的动态规划实现 - 比memoized更简单\n\n    BOTTOM-UP-METHOD(p, n)\n    1 let r[0, 1, ..., n] be a new array\n    2 r[0] = 0\n    3 for j = 1 to n\n    4     q = -1\n    5     for idx = 1 to j\n    6         q = max(q, p[idx] + r[j-idx])\n    7    r[j] = q\n    8 return r[n]\n\n    一定要注意 python 和 伪代码 在数组索引上的相互转换.\n    伪代码中, 数组开始索引是 1\n    python中, 数组开始索引是 0"
      ],
      "my_code": [
        "def rec(p, n):\n    if n == 0:\n        return 0\n    q = -1\n    for i in range(0, n):\n        q = max(q, p[i] + rec(p, n-i-1))\n    return q",
        "def memoized(p, n):\n    r = [-1] * (n + 1)\n\n    def memoized_aux(_p, _n, _r):\n        if _r[_n] >= 0:\n            return _r[_n]\n        if _n == 0:\n            _q = 0\n        else:\n            _q = -1\n        for _i in range(0, _n):\n            # 这传入的第2个参数是 n-i-1, 而不是伪代码中的n-i, 是因为伪代码的数组索引是从1到n, 而python数组索引是从0到n-1, 所以相比伪代码, 要整体减1\n            _q = max(_q, p[_i] + memoized_aux(_p, _n-_i-1, _r))\n        _r[_n] = _q\n        return _q\n    return memoized_aux(p, n, r)",
        "def bottom_top(p, n):\n    r = [-1] * (n + 1)\n    r[0] = 0\n\n    end = n + 1\n    for j in range(1, end):\n        q = -1\n        for idx in range(0, j):\n            # 在这里, q代表: 不切的话, 整条长度的价格\n            # p[idx] 表示切的话, 切完后的右半部分, r[j - idx - 1]代表左半部分\n            q = max(q, p[idx] + r[j - idx - 1])\n        r[j] = q\n    return r[n]\n"
      ]
    }
  }

}