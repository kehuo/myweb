## 概述
[My Github Link](https://github.com/kehuo/algorithm_py3)

### 动态规划概念
动态规划通常用来解决最优化问题. 在这类问题中, 我们通过做出一组选择来达到最优解. 
在做出每个选择的同时, 通常会生成和原问题形式相同的子问题. 当多于一个选择子集都
生成相同的子问题时, 动态规划就很有效.

动态规划的关键技术就是对每个这样的子问题都保存其解, 当其重复出现时, 可以避免重复
求解此问题.

动态规划的思路, 可以将指数时间的算法转换成多项式时间的算法.
 
### 与分治法的比较

1. 相同点

> 动态规划和分治法类似, 都是通过 "组合子问题的解" 来求解原问题.

2. 不同点

> <1> 分治法将问题转化为 **互不相交** 的子问题, 递归地求解每个子问题, 再将它们的解
组合起来.

> <2> 动态规划中, 也有子问题, 但是和分治法不同的是, 动态规划中的子问题可能会 **重复** 的,
也就是说, 当不同的子问题具有公共的子子问题 (子问题的求解是递归进行的, 将其分解为更小
的子子问题)

> 所以, 如果让分治法去求解 "有重复子子问题" 的问题, 它就会反复的求解同样的公共子问题.
而动态规划对每个子子问题只求解一次, 并将其保存在一个表格中, 从而保证无需每次需要子子问题
的解时, 都从头去重复计算, 避免了这种重复工作.

### 动态规划的一般步骤

动态规划通常用来求解最优化问题 (optimization problem). 这类问题可以有很多可行的
解, 每个解都有一个值, 而我们希望寻找的是具有最优值 (比如最小值或最大值) 的解. 我们
称这样的解, 是问题的其中一个最优解 (an optimal solution), 而不是唯一的一个最优
解 (the optimal solution), 因为可能有多个解都达到最有值.

通常, 我们按照以下4个步骤来设计一个动态规划算法

1. 刻画一个最优解的结构特征
2. 递归地定义最优解的值
3. 计算最优解的值 (通常采用自底向上的方法, 具体会在后面章节详细介绍)
4. 利用计算出的信息构造一个最优解

其中, 步骤1-3是动态规划解的基础. 如果我们仅需要一个最优解的值, 而非解本身, 那么
步骤1-3足矣. 如果确实需要步骤4, 有时就需要在构造步骤3的过程中, 维护一些额外信息, 以
便用来构造一个最优解.

### 本节的问题实践 -- 钢条切割

某公司购买长钢条, 然后将其切割为短钢条出售. 切割工序本身不需要付钱. 公司需要知道如何切割能获取最大收益.

假设公司出售切割好的钢条价格表如下:

|         |   |   |   |   |   |   |   |   |   |   |
|---------|---|---|---|---|---|---|---|---|---|---|
| 长度 i    | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 |
| 价格 p(i) | 1  | 5  | 8  | 9  | 10 | 17 | 17 | 20 | 24 | 30 |

**钢条切割问题**是这样的: 给定一段长度为 n 的钢条和一个价格表 p(i) = (i=1, 2, ..., n), 求钢条切割方案, 使
销售收益 r(n) 最大. 注意, 如果长度为 n 的钢条的价格 p (n) 足够大, 那么最优解可能是完全不需要切割此钢条.

思路: 现考虑一个 n = 4 的情况, 下表给出了所有可能的切割方案 (包括根本切割的方案).

|   切割方案  | 价格分布 | 切割后的总价格 |
| --- | ------- | --- |
| 不切割 |  p(4) | 9 |
| 1/3 | p(1) + p(3) | 1 + 8 = 9  |
| 2/2 | p(2) + p(2) | 5 + 5 = 10 |
| 3/1 | p(3) + p(1) | 8 + 1 = 9 |
| 1/1/2 | p(1) + p(1) + p(2) | 1 + 1 + 5 = 7 |
| 1/2/1 | p(1) + p(2) + p(1) | 1 + 5 + 1 = 7 |
| 2/1/1 | p(2) + p(1) + p(1) | 5 + 1 + 1 = 7 |
| 1/1/1/1 | p(1) + p(1) + p(1) + p(1) | 1 + 1 + 1 + 1 = 4 |

从上表我们发现, 如果将一个长度为4个钢条, 一共有8种切割方案, 并且, 如果切割成两段长度各为2的短钢条, 将获得最大
收益5+5=10.

我们将钢条长度从4扩展到n, 那么钢条一共有 2^^(n-1) 种切割方案 (比如n=4时, 一共有 2^^(4-1) = 2^^3 = 8 种方案).

如果我们用 4 = 1 + 1 + 2 表示 "将长度为4的钢条切割成三段 -- 第一段长度为1, 第二段长度也为1, 第三段长度为2",
那么我们可以将其一般化为通用公式:

如果一个最优解将钢条切割为 k 段(1 <= k <= n), 那么最优切割方案是:

n = i(1) + i(2) + ... + i(k)

其中 i(k) 代表长度为 i(k) 的一小段钢条, 那么得到的最大收益是:

r(n) = p(i(1)) + p(i(2)) + ... + p(i(k))

对于上述的价格表样例, 我们可以观察所有的最优收益值 r(i), 其中 1<=i<=n, 以及对应的最优切割方案:

| r(n) | 切割方案 |
| --- | --- |
| r(1) = 1   | 1 = 1 (没有切割) |
| r(2) = 5   | 2 = 1 (没有切割) |
| r(3) = 8   | 3 = 3 (没有切割) |
| r(4) = 10  | 4 = 2 + 2 |
| r(5) = 13  | 5 = 2 + 3 |
| r(6) = 17  | 6 = 6 (没有切割) |
| r(7) = 18  | 7 = 1 + 6 或者 7 = 2 + 2 + 3 |
| r(8) = 22  | 8 = 2 + 6 |
| r(9) = 25  | 9 = 3 + 6 |
| r(10) = 30 | 10 = 10 (没有切割) |

更一般地, 对于 r(n) (n>=1), 我们可以用以下更短钢条的最优切割收益来描述它:

r(n) = max([p(n)], [r(1) + r(n-1)], [r(2) + r(n-2)], ..., [r(n-1) + r(1)])

以上公式中, [p(n)] 表示不切割, 直接出售长度为n的初始长钢条的切割方案. 其他 n-1 个参数对应另外 n-1 种
方案: 对于每个 i=1, 2, 3, ..., n-1, 首先将钢条切割为长度为 i 和 n-i 的2段, 接着求解这2段的最优切割
收益, r(i) 和 r(n-i), 其中每种方案的总收益等于两段的收益之和. 如果无法预知哪种会获得最大收益, 那么我们
必须考察所有的 i, 最后选取其中收益最大者. 如果直接出售原钢条会获得最大收益, 我们当然可以选择不做任何切割.

**注意到, 为了求解规模为 n 的原问题, 我们先会求解形式完全一样, 但规模更小的子问题. 也就是说, 当完成首次
切割后, 我们将2段钢条看成2个独立的钢条切割问题实例. 我们通过组合2个相关子问题的最优解, 并在所有可能的2
段切割方案中, 选取组合收益最大的方案, 并构成原问题的最优解.**

**我们称 "钢条切割问题" 满足最优子结构 (optimal substructure) 性质, 即问题的最优解由相关子问题的
最优解组合而成, 而且这些子问题可以被独立求解.** 

## 3 种不同方式的代码实现
### 1 - 自顶向下的递归实现
#### 简介

> 在递归方法中, 以价格数组p 和整数 n 为输入, 返回长度为 n 的钢条的最大收益. 若 n = 0,
则不可能有收益, 所以第二行返回0. 第三行将最大收益初始化为 -1, 以便第4-5行的 for 循环
能正确计算 q, 第6行返回计算结果.

> 缺点: 大量的重复计算, 这个算法在不断地求解相同的子问题. 导致这个算法的时间复杂度
>达到了指数级别. n每增加1, 复杂度就上涨一倍.

#### 伪代码:
    CUT(p, n)
    1 if n == 0
    2     return 0
    3 q = -1
    4 for i = 1 to n
    5     q = max(q, p[i]+CUT(p, n-i))
    6 return q

### 2 - 动态规划实现
#### 简介

> 思想:
>   > 我们已经看到, 上面的朴素递归方法效率很低, 而且原因是反复求解相同的子问题. 因此,
动态规划会仔细地安排求解顺序, 对每个问题只求解一次, 并将结果保存下来.
>   > 如果随后再次需要此问题的解， 只需要查找保存的结果, 而不必重新计算.
>   > 因此, 动态规划的方法是用额外的内存空间来节省计算时间, 是典型的时空权衡的例子. (
time-memory trade-off). 这个方法在时间上的节省程度可能是非常巨大的, 可能将一个指数
时间的解转化为一个多项式时间的解. 如果子问题的数量是输入规模的多项式函数, 而我们可以在
多项式时间内求解出每个子问题, 那么动态规划方法的总运行时间就是多项式阶的.

### 2.1 动态规划实现之一: 带备忘的自顶向下法 (top-down with memoization)
#### 简介

此方法仍然按照自然的递归形式编写过程, 但过程中, 会保存每个子问题的解(通常保存在一个数组
或者散列表中). 当需要一个子问题的解时, 算法会首先检查是否已经保存过此解. 如果是, 则直
接返回保存的值, 从而节省了计算时间; 否则, 按照通常方式计算这个子问题.

我们称这个递归过程是带备忘的 (memoized). 因为它 "记住" 了之前计算出的结果.

#### 伪代码
    MEMOIZED-CUT-ROD(p, n)
    1 let r[0, 1, ..., n] be a new array
    2 for i = 0 to n
    3   r[i] = -1
    4 return MEMOIZED-CUT-ROD-AUX(p, n, r)

    (其中 MEMOIZED-CUT-ROD-AUX 函数定义如下)
    MEMOIZED-CUT-ROD-AUX(p, n, r)
    1 if r[n] >= 0
    2     return r[n]
    3 if n == 0
    4     q = 0
    5 else q = -1
    6 for i = 1 to n
    7     q = max(q, p[i] + MEMOIZED-CUT-ROD-AUX(p, n-i, r))
    8 r[n] = q
    9 return q

#### Python 实现
(伪代码和python实现最大的区别是数组的开始索引不同. 
伪代码从1开始, 而python数组的索引从0开始)

    def memoized(p, n):
        r = [-1] * (n + 1)

        def memoized_aux(_p, _n, _r):
            if _r[_n] >= 0:
                return _r[_n]
            if _n == 0:
                _q = 0
            else:
                _q = -1
            for _i in range(0, _n):
                _q = max(_q, p[_i] + memoized_aux(_p, _n-_i-1, _r))
            _r[_n] = _q
            return _q
        return memoized_aux(p, n, r)

### 2.2 - 动态规划实现之二: 自底向上(bottom-up)
#### 简介

这种方法一般需要恰当地定义子问题的 "规模" 的概念, 使得任何子问题的求解都只依赖于更小的
子问题的求解. 因此, 我们可以将子问题按照规模排序, 按由小至大的顺序进行求解.

当求解某个子问题时, 它所依赖的那些更小的子问题, 都已经求解完毕, 结果已经保存. 每个子问
题只需求解一次, 当我们求解它(也是第一次遇到它)时, 它的所有前提子问题都已求解完成.  

#### 伪代码
    BOTTOM-UP-METHOD(p, n)
    1 let r[0, 1, ..., n] be a new array
    2 r[0] = 0
    3 for j = 1 to n
    4     q = -1
    5     for idx = 1 to j
    6         q = max(q, p[idx] + r[j-idx])
    7    r[j] = q
    8 return r[n]

#### Python 实现
    def bottom_top(p, n):
        r = [-1] * (n + 1)
        r[0] = 0
    
        end = n + 1
        for j in range(1, end):
            q = -1
            for idx in range(0, j):
                # 在这里, q代表"不切的话, 整条长度的价格"
                # p[idx] 表示切的话, 切完后的右半部分, r[j-idx-1]代表左半部分
                q = max(q, p[idx] + r[j - idx - 1])
            r[j] = q
        return r[n]

